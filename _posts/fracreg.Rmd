---
title: "Fractional Regression"
description: |
  A quick primer regarding data between zero and one including zero and one.
author:
  - name: Michael Clark
    url: https://m-clark.github.io
date: '`r format(Sys.Date(), "%B %d, %Y")`'
preview: ../../img/198R.png   # apparently no way to change the size displayed via css (ignored) or file (stretched)
output:
  distill::distill_article:
    self_contained: false
    toc: true
    css: ../../styles.css
draft: true
tags: [fractional regression, beta regression, logistic regression, zero inflated, one inflated, percentage, fraction, stata, fracreg]
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo=T, 
  message = F, 
  warning = F, 
  comment = NA,
  R.options=list(width=120), 
  cache.rebuild=F, 
  cache=FALSE,
  fig.align='center', 
  dev = 'svg', 
  dev.args=list(bg = 'transparent')
)

library(tidyverse); library(broom); library(kableExtra); library(visibly)
kable_df <- function(..., digits=3) {
  kable(..., digits=digits) %>% 
    kable_styling(full_width = F)
}
```

## Introduction

It is often the case you might have data that primarily falls between zero and one.  For example, these may be percentages for which you don't know the total count, grades from 0-100 that can be transformed as such, and similar. If they are counts/proportions where you knew the denominator, or a binary outcome, you would be able to just use standard logistic regression with the binomial distribution.  Additionally, if all the data lies between zero and one, <span class="emph" style = "">beta regression</span> is a natural choice for which to model such functions.  However, beta regression can only deal with values between zero and one, so if you have zeros or ones, what can one do?

Some suggest adding a fudge factor to the zeros or ones to put them on the (0,1) interval. However, such hacks are unnecessary these days.  Furthermore, you already have tools that model this sort of target variable.

## Stata example

It might seem strange to start with an example using Stata.  But if you look this sort of thing up, you'll almost certainly come across the Stata example using the <span class="func" style = "">fracreg</span> command.  The following specifies a fractional regression with logit link.

```{stata stata, engine.path="C:/Program Files/Stata16/StataSE-64.exe", eval=F}
use http://www.stata-press.com/data/r14/401k

fracreg logit prate mrate c.ltotemp c.age i.sole
```

This is one of the few tools that is readily available to model such outcomes, but you definitely don't need Stata once you know what's going on.

## R GLM

It turns out that the likelihood for fractional regression is just the stanard binomial likelihood we would use for binary or count/proportional outcomes.  In the following, $y$ is our target variable, $X\beta$ is the linear predictor, and $g(.)$ is the link function, for example, the logit.

$$\mathcal{L} \sim y(\ln{g(X\beta)}) + (1-y)(1-\ln{g(X\beta)})$$

As such, we can just use <span class="func" style = "">glm</span> like we would for count/binary outcomes. It will warn you that the outcome isn't integer as expected, but in this case we can just ignore the warning.

```{r glm, warning=TRUE}
d = haven::read_dta('data/401k.dta')

model_glm = glm(prate ~ mrate + ltotemp + age + sole, d, family = binomial)

# summary(model_glm)
```

```{r glm-summary, echo=FALSE}
tidy(model_glm) %>% 
  kable_df()
```


## Robust standard errors

Stata by default does robust standard errors, but that is not required. You can use the sandwich package to get them in R.

```{r robust-se}
library(lmtest)
library(sandwich)

se_glm_robust = coeftest(model_glm, vcov = vcovHC(model_glm, type="HC"))
```

```{r robust-se-print, echo=FALSE}
tidy(se_glm_robust) %>% 
  kable_df()
```


## Quasibinomial

We could also use the <span class="emph" style = "">quasibinomial</span> family.  [Quasi-likelihoods](https://en.wikipedia.org/wiki/Quasi-likelihood) are similar to standard likelihood functions. but are technically do not relate to any particular probability distribution. Using this family would  provides the same result as previous, but without the warning.

```{r quasi}
model_quasi = glm(prate ~ mrate + ltotemp + age + sole, d, family = quasibinomial)

summary(model_quasi)

se_glm_robust_quasi = coeftest(model_quasi, vcov = vcovHC(model_quasi, type="HC"))

se_glm_robust_quasi
```

## Mixed model with per-observation random effect

Try glmer with the observation level RE.  All failed to converge. Not shown.

```{r lme4, eval=1}
d$id = 1:nrow(d)
model_glmm = lme4::glmer(prate ~ mrate + ltotemp + age + sole + (1|id), d, family = binomial)
test = lme4::allFit(model_glmm)
summary(test)
summary(model_glmm, cor=F)
```

Try a gam instead.


This is just a glm with REML.

```{r mgcv}
library(mgcv)
model_gam_std = gam(
  prate ~ mrate + ltotemp + age + sole, 
  d, 
  family = binomial, 
  method = 'REML'
)
summary(model_gam_std)

se_gam_std = coeftest(model_gam_std, vcov = vcovHC(model_gam_std, type="HC"))
```

Add per observation random effect.

```{r mgcv-re}
model_gam_re = gam(
  prate ~ mrate + ltotemp + age + sole + s(id, bs = 're'),
  d,
  family = binomial,
  method = 'REML'
)

summary(model_gam_re)

se_gam_std_re = coeftest(model_gam_re, vcov = vcovHC(model_gam_re, type="HC"))
```

```{r mgcv2}
model_gam_re_quasi = gam(
  prate ~ mrate + ltotemp + age + sole + s(id, bs = 're'),
  d,
  family = quasibinomial,
  method = 'REML'
)

summary(model_gam_re_quasi)

se_gam_std_re_quasi = coeftest(model_gam_re_quasi, vcov = vcovHC(model_gam_re_quasi, type="HC"))
```


```{r robust-se-summary, echo=FALSE}
robust = mget(ls(pattern = '^se\\_'))

robust %>% 
  map_df(function(x) data.frame(x[,'Estimate', drop=F]), .id = 'model') %>% 
  tidyext::spread2(model, value = `Estimate`) %>% 
  slice(-6) %>%   # remove se for smooth
  kable_df(digits = 4, caption = 'Coefficients')
robust %>% 
  map_df(function(x) data.frame(x[,'Std. Error', drop=F]), .id = 'model') %>% 
  tidyext::spread2(model, value = `Std..Error`) %>% 
  slice(-6) %>%   # remove se for smooth
  kable_df(digits = 4, caption = 'Standard Errors')
```


Can glmer do fractional binomial in the standard binomial case? Yes.  But it's gotten to the point I don't trust `glmer`, as it has problems for almost any model with its current default settings.  Here it would have us believe there is no country level variance and that life expectancy is going down over time. Wtf?

```{r true-mixed}
library(noiris)
init = gapminder_2019 %>% 
  filter(year > 2000) %>%
  mutate(
    le_frac = lifeExp/max(lifeExp, na.rm = T), 
    year = year - min(year),
    country = factor(country)
  )

library(lme4)
mixed_glm_frac = glmer(le_frac ~ year + (1|country), data=init, family = binomial) 
summary(mixed_glm_frac, cor=F)


library(optimx)
mixed_glm_frac2 = glmer(
  le_frac ~ year + (1 | country),
  data = init,
  family = binomial,
  control = glmerControl(optimizer = 'optimx', optCtrl = list(method =
                                                                'L-BFGS-B'))
) 
summary(mixed_glm_frac2, cor=F)
```

`mgcv` on the other hand, produces sensible results relative to standard glm and fracreg.  I also tried frm package, but that is a serious PoS.

```{r true-mixed-gam}
mixed_gam_frac = gam(le_frac ~ year + s(country, bs='re'), data=init, family = binomial, method = 'REML') 

summary(mixed_gam_frac)
gammit::extract_vc(mixed_gam_frac)  # clearly country level variance
coeftest(mixed_gam_frac, vcov = vcovHC(mixed_gam_frac, type="HC"))[1:2,]

# not far from glm
glm_frac = glm(le_frac ~ year, data=init, family = quasibinomial)
# summary(glm(le_frac ~ year, data=init, family = quasibinomial))
coeftest(glm_frac, vcov = vcovHC(glm_frac, type="HC", cluster="country"))



```


frm package not recommended, doesn't use data frames, requiers separate variables from the data matrix, etc.

```{r frm, eval=FALSE}
# seriously?
# le_frac = na.omit(init$le_frac)
# year = matrix(init$year[-attr(le_frac, which = 'na.action')], ncol = 1)
# clus = as.numeric(factor(init$country[-attr(le_frac, which = 'na.action')]))
# colnames(year) = c('year')
# 
# frm::frm(le_frac, year, linkfrac = 'logit', var.cluster=clus)
```



## References

[Stata demo](https://www.stata.com/features/overview/fractional-outcome-models/)