[
["index.html", "An Introduction to Machine Learning", " An Introduction to Machine Learning Michael Clark 2017-04-21 "],
["preface.html", "Preface", " Preface The purpose of this document is to provide a conceptual introduction to statistical or machine learning (ML) techniques for those that might not normally be exposed to such approaches during their typical required statistical training. Machine learning1 can be described as a form of a statistics, often even utilizing well-known and familiar techniques, that has bit of a different focus than traditional analytical practice in the social sciences and other disciplines. The key notion is that flexible, automatic approaches are used to detect patterns within the data, with a primary focus on making predictions on future data. If one surveys the number of techniques available in ML without context, it will surely be overwhelming in terms of the sheer number of those approaches, as well as the various tweaks and variations of them. However, the specifics of the techniques are not as important as more general concepts that would be applicable in most every ML setting, and indeed, many traditional ones as well. While there will be examples using the R statistical environment and descriptions of a few specific approaches, the focus here is more on ideas than application2 and kept at the conceptual level as much as possible. However, some applied examples of more common techniques will be provided in detail. As for prerequisite knowledge, I will assume a basic familiarity with regression analyses typically presented to those in applied disciplines. Regarding programming, one should be at least somewhat familiar with using R and RStudio, and there are plenty of introductions out there for those wishing to learn. Note that I won’t do as much explaining of the R code, and in some cases I will be more concerned with getting to a result than clearly detailing the path to it. Armed with such introductory knowledge as can be found in those documents, if there are parts of R code that are unclear one would have the tools to investigate and discover for themselves the details, which results in more learning anyway. The latest version of this document is dated 2017-04-21 (original March 2013). Color coding in text: emphasis package function object/class link A final note, this document is prepared testing mostly with the Chrome and Firefox browsers on large screens. While capable of being perused on smaller screens largely without issue, I’m far more interested in how it looks in more viable context. Also referred to as applied statistical learning, statistical engineering, data science or data mining in other contexts.↩ Indeed, there is evidence that with large enough samples many techniques converge to similar performance.↩ "],
["introduction.html", "Introduction Explanation &amp; Prediction Some Terminology", " Introduction Explanation &amp; Prediction For any particular analysis conducted, emphasis can be placed on understanding the underlying mechanisms which have specific theoretical underpinnings, versus a focus that dwells more on performance and, more to the point, future performance. These are not mutually exclusive goals in the least, and probably most studies contain a little of both in some form or fashion. I will refer to the former emphasis as that of explanation, and the latter that of prediction. In studies with a more explanatory focus, traditionally analysis concerns a single data set. For example, one assumes a data generating distribution for the response, and one evaluates the overall fit of a single model to the data at hand, e.g. in terms of R-squared, and statistical significance for the various predictors in the model. One assesses how well the model lines up with the theory that led to the analysis, and modifies it accordingly, if need be, for future studies to consider. Some studies may look at predictions for specific, possibly hypothetical values of the predictors, or examine the particular nature of individual predictors effects. In many cases, only a single model is considered. In general though, little attempt is made to explicitly understand how well the model will do with future data, but we hope to have gained greater insight as to the underlying mechanisms guiding the response of interest. Following Breiman (2001), this would be more akin to the data modeling culture. For the other type of study focused on prediction, newer techniques are available that are far more focused on performance, not only for the current data under examination but for future data the selected model might be applied to. While still possible, relative predictor importance is less of an issue, and oftentimes there may be no particular theory to drive the analysis. There may be thousands of input variables, such that no simple summary would likely be possible anyway. However, many of the techniques applied in such analyses are quite powerful, and steps are taken to ensure better results for new data. Again referencing Breiman (2001), this perspective is more of the algorithmic modeling culture. While the two approaches are not exclusive, I present two extreme (though thankfully dated) views of the situation3: To paraphrase provocatively, ‘machine learning is statistics minus any checking of models and assumptions’. \\(\\sim\\) Brian Ripley, 2004 … the focus in the statistical community on data models has: - Led to irrelevant theory and questionable scientific conclusions. - Kept statisticians from using more suitable algorithmic models. - Prevented statisticians from working on exciting new problems. \\(\\sim\\) Leo Brieman, 2001 Respective departments of computer science and statistics now overlap more than ever, as more relaxed views prevail today, but there are potential drawbacks to placing too much emphasis on either approach historically associated with them. Models that ‘just work’ have the potential to be dangerous if they are little understood. Situations for which much time is spent sorting out details for an ill-fitting model suffers the converse problem- some (though often perhaps very little actually) understanding with little pragmatism. While this document will focus on more algorithmic approaches, guidance will be provided with an eye toward their use in situations where the typical data modeling approach would be applied, thereby hopefully shedding some light on a path toward obtaining the best of both worlds. Some Terminology For those used to statistical concepts such as dependent variables, clustering, and predictors, etc. you will have to get used to some differences in terminology4 such as targets, unsupervised learning, and features etc. It doesn’t take too much to get acclimated, even if it is somewhat annoying when one is first starting out. I won’t be too beholden to either in this paper, and it should be clear from the context what’s being referred to. Initially I will start off mostly with non-ML terms and note in brackets it’s ML version to help the orientation along. References "],
["tools.html", "Tools The Standard Linear Model Logistic Regression Expansions of Those Tools", " Tools One thing that is important to keep in mind as you begin is that standard techniques are still available, although we might tweak them or do more with them. So having a basic background in statistics is all that is required to get started with machine learning. Again, the difference between ML and traditional statistical analysis is more of focus than method. The Standard Linear Model All introductory statistics courses will cover linear regression in great detail, and it certainly can serve as a starting point here. We can describe it as follows in matrix notation: \\[\\mu = X\\beta\\] \\[y \\sim N(\\mu,\\sigma^{2})\\] Where y is a normally distributed vector of responses [target] with mean \\(\\mu\\) and constant variance \\(\\sigma^{2}\\). X is a typical model matrix, i.e. a matrix of predictor variables and in which the first column is a vector of 1s for the intercept [bias]5, and \\(\\beta\\) is the vector of coefficients [weights] corresponding to the intercept and predictors in the model matrix. What might be given less focus in applied courses however is how often it won’t be the best tool for the job or even applicable in the form it is presented. Because of this many applied researchers are still hammering screws with it, even as the explosion of statistical techniques of the past quarter century has rendered obsolete many current introductory statistical texts that are written for disciplines. Even so, the concepts one gains in learning the standard linear model are generalizable, and even a few modifications of it, while still maintaining the basic design, can render it still very effective in situations where it is appropriate. Typically in fitting [learning] a model we tend to talk about R-squared and statistical significance of the coefficients for a small number of predictors. For our purposes, let the focus instead be on the residual sum of squares6 with an eye towards its reduction and model comparison. We will not have a situation in which we are only considering one model fit, and so must find one that reduces the sum of the squared errors but without unnecessary complexity and overfitting, concepts we’ll return to later. Furthermore, we will be much more concerned with the model fit on new data [generalization]. Logistic Regression Logistic regression is often used where the response is categorical in nature, usually with binary outcome in which some event occurs or does not occur [label]. One could still use the standard linear model here, but you could end up with nonsensical predictions that fall outside the 0-1 range regarding the probability of the event occurring, to go along with other shortcomings. Furthermore, it is no more effort nor is any understanding lost in using a logistic regression over the linear probability model. It is also good to keep logistic regression in mind as we discuss other classification approaches later on. Logistic regression is also typically covered in an introduction to statistics for applied disciplines because of the pervasiveness of binary responses, or responses that have been made as such7. Like the standard linear model, just a few modifications can enable one to use it to provide better performance, particularly with new data. The gist is, it is not the case that we have to abandon familiar tools in the move toward a machine learning perspective. Expansions of Those Tools Generalized Linear Models To begin, logistic regression is a generalized linear model assuming a binomial distribution for the response and with a logit link function as follows: \\[\\eta = X\\beta\\] \\[\\eta = g(\\mu)\\] \\[y \\sim \\mathrm{Bin}(\\mu, size=1)\\] This is the same presentation format as seen with the standard linear model presented before, except now we have a link function \\(g(.)\\) and so are dealing with a transformed response. In the case of the standard linear model, the distribution assumed is the Gaussian and the link function is the identity link, i.e. no transformation is made. The link function used will depend on the analysis performed, and while there is choice in the matter, the distributions used have a typical, or canonical link function8. Generalized linear models expand the standard linear model, which is a special case of generalized linear model, beyond the Gaussian distribution for the response, and allow for better fitting models of categorical, count, and skewed response variables. We have also have a counterpart to the residual sum of squares, though we’ll now refer to it as the deviance. Generalized Additive Models Additive models extend the generalized linear model to incorporate nonlinear relationships of predictors to the response. We might note it as follows: \\[\\eta = X\\beta + f(Z)\\] \\[\\eta = g(\\mu)\\] \\[y \\sim \\mathrm{family}(\\mu, ...)\\] So we have the generalized linear model but also smooth functions \\(f(Z)\\) of one or more predictors. More detail can be found in Wood (2006) and I provide an introduction here. Things do start to get fuzzy with GAMs. It becomes more difficult to obtain statistical inference for the smooth terms in the model, and the nonlinearity does not always lend itself to easy interpretation. However, really this just means that we have a little more work to get the desired level of understanding. GAMs can be seen as a segue toward more black box/algorithmic techniques. Compared to some of those techniques in machine learning, GAMs are notably more interpretable, though GAMs are perhaps less so than GLMs. Also, part of the estimation process includes regularization and validation in determining the nature of the smooth function, topics of which we will return later. References "],
["the-loss-function.html", "The Loss Function Continuous Outcomes Categorical Outcomes", " The Loss Function Given a set of predictor variables \\(X\\) and some target \\(y\\), we look for some function \\(f(X)\\) to make predictions of y from those input variables. We also need a function to penalize errors in prediction- a loss function, \\(L(Y, f(X))\\). With a chosen loss function, we then find the model which will minimize loss, generally speaking. We will start with the familiar and note a couple others that might be used. Continuous Outcomes Squared Error The classic loss function for linear models with continuous response is the squared error loss function, or the residual sum of squares. \\[L(Y, f(X)) = \\sum(y-f(X))^2\\] Absolute Error For an approach more robust to extreme observations, we might choose absolute rather than squared error as follows. In this case, predictions are a conditional median rather than a conditional mean. \\[L(Y, f(X)) = \\sum|(y-f(X))|\\] Negative Log-likelihood We can also think of our usual likelihood methods learned in a standard applied statistics course as incorporating a loss function that is the negative log-likelihood pertaining to the model of interest. If we assume a normal distribution for the response we can note the loss function as: \\[L(Y, f(X)) = n\\ln{\\sigma} + \\sum \\frac{1}{2\\sigma^2}(y-f(X))^2\\] In this case it would converge to the same answer as the squared error/least squares solution. R Example The following provides code that one could use with the optim function in R to find estimates of regression coefficients (beta) that minimize the squared error. X is a design matrix of our predictor variables with the first column a vector of 1s in order to estimate the intercept. y is the continuous variable to be modeled9. sqerrloss = function(beta, X, y){ mu = X%*%beta sum((y-mu)^2) } # data setup set.seed(123) N = 100 X = cbind(1, rnorm(N), rnorm(N)) beta = c(0, -.5, .5) y = rnorm(N, X%*%beta, sd=1) # results our_func = optim(par=c(0,0,0), fn=sqerrloss, X=X, y=y, method=&#39;BFGS&#39;) lm_result = lm(y ~ ., data.frame(X[,-1])) # check with lm rbind(c(our_func$par, our_func$value), c(coef(lm_result), sum(resid(lm_result)^2))) (Intercept) X1 X2 [1,] 0.1350654 -0.6331715 0.5238113 87.78187 [2,] 0.1350654 -0.6331715 0.5238113 87.78187 Categorical Outcomes Here we’ll also look at some loss functions useful in classification problems. Note that there is not necessary exclusion in loss functions for continuous vs. categorical outcomes10. Generally though we’ll have different options. Misclassification Probably the most straightforward is misclassification, or 0-1 loss. If we note \\(f\\) as the prediction, and for convenience we assume a [-1,1] response instead of a [0,1] response: \\[L(Y, f(X)) = \\sum I(y\\neq \\mathrm{sign}(f))\\] In the above, \\(I\\) is the indicator function, and so we are simply summing misclassifications. Binomial log-likelihood \\[L(Y, f(X)) = \\sum log(1 + e^{-2yf})\\] The above is in deviance formDeviance can conceptually be thought of as the GLM version of residual variance., but is equivalent to binomial log likelihood if \\(y\\) is on the 0-1 scale. Exponential Exponential loss is yet another loss function at our disposal. \\[L(Y, f(X)) = \\sum e^{-yf}\\] Hinge Loss A final loss function to consider, typically used with support vector machines, is the hinge loss function. \\[L(Y, f(X)) = \\max(1-yf, 0)\\] Here negative values of \\(yf\\) are misclassifications, and so correct classifications do not contribute to the loss. We could also note it as \\(\\sum (1-yf)_+\\) , i.e. summing only those positive values of \\(1-yf\\). Which of these might work best may be specific to the situation, but the gist is that they penalize negative values (misclassifications) more heavily and increasingly so the worse the misclassification (except for misclassification error, which penalizes all misclassifications equally), with their primary difference in how heavy that penalty is. At right is a depiction of the loss as a functions above, taken from Hastie, Tibshirani, and Friedman (2009). References "],
["regularization.html", "Regularization R Example", " Regularization It is important to note that a model fit to a single data set might do very well with the data at hand, but then suffer when predicting independent data11. Also, oftentimes we are interested in a ‘best’ subset of predictors among a great many, and in this scenario the estimated coefficients are overly optimistic. This general issue can be improved by shrinking estimates toward zero, such that some of the performance in the initial fit is sacrificed for improvement with regard to prediction. Penalized estimation will provide estimates with some shrinkage, and we can use it with little additional effort with our common procedures. Concretely, let’s apply this to the standard linear model, where we are finding estimates of \\(\\beta\\) that minimize the squared error loss. \\[\\hat\\beta = \\underset{\\beta}{\\mathrm{arg\\, min}} \\sum{(y-X\\beta)^2}\\] In words, we’re finding the coefficients that minimize the sum of the squared residuals. With the approach to regression here we just add a penalty component to the procedure as follows. \\[\\hat\\beta = \\underset{\\beta}{\\mathrm{arg\\, min}} \\sum{(y-X\\beta)^2} + \\lambda\\overset{p}{\\underset{j=1}{\\sum}}{\\left|\\beta_j\\right|}\\] In the above equation, \\(\\lambda\\) is our penalty term12 for which larger values will result in more shrinkage. It’s applied to the \\(L_1\\) or Manhattan norm of the coefficients, \\(\\beta_1,\\beta_2...\\beta_p\\), i.e. not including the intercept \\(\\beta_0\\), and is the sum of their absolute values (commonly referred to as the lasso13). For generalized linear and additive models, we can conceptually express a penalized likelihood as follows: \\[l_p(\\beta) = l(\\beta) - \\lambda\\overset{p}{\\underset{j=1}{\\sum}}{\\left|\\beta_j\\right|}\\] As we are maximizing the likelihood the penalty is a subtraction, but nothing inherently different is shown. This basic idea of adding a penalty term will be applied to all machine learning approaches, but as shown, we can apply such a tool to classical methods to boost prediction performance. Interestingly, the lasso and ridge regression results can be seen as a Bayesian approach using a zero mean Laplace and Normal prior distribution respectively for the \\(\\beta_j\\).It should be noted that we can go about the regularization in different ways. For example, using the squared \\(L_2\\) norm results in what is called (a.k.a. Tikhonov regularization), and using a weighted combination of the lasso and ridge penalties gives us elastic net regularization. R Example In the following example, we take a look at the lasso approach for a standard linear model. We add the regularization component, with a fixed penalty \\(\\lambda\\) for demonstration purposes14. However you should insert your own values for \\(\\lambda\\) in the optim line to see how the results are affected. sqerrloss_reg = function(beta, X, y, lambda=.1){ mu = X%*%beta sum((y-mu)^2) + lambda*sum(abs(beta[-1])) } regularized_result = optim(par=c(0,0,0), fn=sqerrloss_reg, X=X, y=y, method=&#39;BFGS&#39;) rbind(c(our_func$par, our_func$value), c(coef(lm_result),sum(resid(lm_result)^2)), c(regularized_result$par, regularized_result$value) ) (Intercept) X1 X2 [1,] 0.1350654 -0.6331715 0.5238113 87.78187 [2,] 0.1350654 -0.6331715 0.5238113 87.78187 [3,] 0.1349579 -0.6325923 0.5232982 87.89751 # Create test data set.seed(1:3) N_test = 50 X_test = cbind(1, rnorm(N_test), rnorm(N_test)) y_test = rnorm(N_test, X_test%*%beta, sd=1) # squared error loss crossprod(y_test - predict(lm_result, newdata = data.frame(X_test[,-1]))) [,1] [1,] 44.38851 crossprod(y_test - X_test%*%regularized_result$par) [,1] [1,] 44.37794 From the above, we can see in this case that the penalized coefficients have indeed shrunk toward zero slightly, while the residual sum of squares has increased just a tad. In general, we can add the same sort of penalty to any number of models, such as logistic regression, neural net models, recommender systems etc. The primary goal again is to hopefully increase our ability to generalize the selected model to new data. Note that the estimates produced are in fact biased, but we have decreased the variance with new predictions as a counterbalance, and this brings us to the topic of the next section. In terminology we will discuss further later, such models might have low bias but notable variance.↩ This can be set explicitly or also estimated via a validation approach. As we do not know it beforehand, we can estimate it on a validation data set (not the test set) and then use the estimated value when estimating coefficients via cross-validation with the test set. We will talk more about validation later.↩ See Tibshirani (1996) Regression shrinkage and selection via the lasso.↩ As noted previously, in practice \\(\\lambda\\) would be estimated via some validation procedure.↩ "],
["bias-variance-tradeoff.html", "Bias-Variance Tradeoff Bias &amp; Variance The Tradeoff Diagnosing Bias-Variance Issues &amp; Possible Solutions", " Bias-Variance Tradeoff In most of science, we are concerned with reducing uncertainty in our knowledge of some phenomenon. The more we know about the factors involved or related to some outcome of interest, the better we can predict that outcome upon the influx of new information. The initial step is to take the data at hand, and determine how well a model or set of models fit the data in various fashions. In many applications however, this part is also more or less the end of the game as well15. Unfortunately, such an approach in which we only fit models to one data set does not give a very good sense of generalization performance, i.e. the performance we would see with new data. While typically not reported, most researchers, if they are spending appropriate time with the data, are actually testing a great many models, for which the ‘best’ is then provided in detail in the end report. Without some generalization performance check however, such performance is overstated when it comes to new data. In the following consider a standard linear model scenario, e.g. with squared-error loss function and perhaps some regularization, and a data set in which we split the data in some random fashion into a training set , for initial model fit, and atest set, which is a separate and independent data set, to measure generalization performance16. We note training error as the (average) loss over the training set, and test error as the (average) prediction error obtained when a model resulting from the training data is fit to the test data. So in addition to the previously noted goal of finding the ‘best’ model (model selection), we are interested further in estimating the prediction error with new data (model performance). Bias &amp; Variance ConceptuallyMuch of the following is essentially a paraphrase of parts of Hastie, Tibshirani, and Friedman (2009) (chapters 2 and 7)., with the standard model \\(Y = f(X) + \\epsilon\\) with we can think of the expected prediction error at a specific input \\(X = x_0\\) as: \\[\\text{Error}_{x_0} = \\text{Irreducible Error} + \\text{Bias}^2 + \\text{Variance}\\] To better understand this, think of training models over and over, each time with new training data, but testing each model at \\(x_0\\). The \\(\\text{Error}_{x_0}\\) is the average, or expected value of the MSE in this scenario, or \\(E(y - \\hat f(x))^2\\). In other words, we have three components to our general notion of prediction error: Irreducible error: The variance of the (new test) target (\\(\\sigma^2_\\epsilon\\)). This is unavoidable, since our \\(y\\) is measured with error.. \\(Bias^2\\): the amount the average of our estimate varies from the true mean (\\(E(\\hat f) - f\\)). This is typically the result of trying to model the complexity of nature with something much simple that the human brain can understand. Variance: the amount by which our prediction would change if we estimated it using a different training data set (\\(Var(\\hat f)\\)) Slightly more formally, we can present this as follows, with \\(h_0\\) our estimated (hypothesized) value at \\(x_0\\): \\[\\text{Error}_{x_0} = Var(\\epsilon) + (\\text{E}[h_0] - f(x_0))^2 + Var(h_0)\\] The latter two make up the mean squared error in our previous demonstration. While they are under our control, they compete with one another such that oftentimes we improve one at the detriment of the other. The Tradeoff Outlining a general procedure, we start by noting the prediction error on a training data set with multiple models of varying complexity (e.g. increasing the number of predictor variables, adding polynomial terms, including interactions), and then assess the performance of the chosen models in terms of prediction error on the test set. We then perform the same activity for a total of 100 simulated data sets, for each level of complexity. The results from this process might look like the image to the right taken from Hastie, Tibshirani, and Friedman (2009). With regard to the training data, we have \\(\\mathrm{error}_{train}\\) for one hundred training sets for each level of model complexity. The bold blue line notes this average error over the 100 sets by model complexity. The bold red line the average test error (\\(\\mathrm{error}_{test}\\)) across the 100 test data sets. Ideally we’d like to see low bias and variance, but things are not so easy. One thing we can see clearly is that \\(\\mathrm{error}_{train}\\) is not a good estimate of \\(\\mathrm{error}_{test}\\), which is now our focus in terms of performance. If we think of the training error as what we would see in typical research where one does everything with a single data set, we are using the same data set to fit the model and assess error. As the model is adapted to that data set specifically, it will be overly optimistic in the estimate of the error, that optimism being the difference between the error rate we see based on the training data versus the average of what we would get with many test data sets. We can think of this as a problem of overfitting to the training data. Models that do not incorporate any regularization or validation process of any kind are likely overfit to the data presented. Generally speaking, the more complex the model, the lower the bias, but the higher the variance, as depicted in the graphic. Specifically however, the situation is more nuanced, where type of problem (classification with 0-1 loss vs. continuous response with squared error loss17) and technique (a standard linear model vs. regularized fit) will exhibit different bias-variance relationships. Figure adapted from Domingos (2012). Diagnosing Bias-Variance Issues &amp; Possible Solutions Let’s assume a regularized linear model with a standard data split into training and test sets. We will describe different scenarios with possible solutions. Worst Case Scenario Starting with the worst case scenario, poor models may exhibit high bias and high variance. One thing that will not help this situation (perhaps contrary to intuition) is adding more data, i.e. increasing N. You can’t make a silk purse out of a sow’s ear (usually), and adding more data just gives you a more accurate picture of how awful your model is. One might need to rework the model, e.g. adding new predictors or creating them via interaction terms, polynomials, or other smooth functions as in additive models, or simply collecting better and/or more relevant data. Figure inspired by Murphy (2012) (figure 6.5) showing the bias-variance tradeoff. Sample (left) and average (right) fits of linear regression using a Gaussian radial basis function expansion. The green line represents the true relationship. The top row shows low variance between one fit and the next (left) but notable bias (right) in that the average fit is off. Compare to the less regularized (high variance, low bias) situation of the bottom row. See the kernlab package for the fitting function used. High Variance When variance is a problem, our training error is low while test error is relatively high (overfitting problem). Implementing more shrinkage or other penalization to model complexity may help with the issue. In this case more data may help as well. High Bias With bias issues, our training error is high and test error is not too different from training error (underfitting problem). Adding new predictors/features, e.g. interaction terms, polynomials etc., can help here. Additionally reducing the penalty parameter \\(\\lambda\\) would also work with even less effort, though generally it should be estimated rather than explicitly set. References "],
["cross-validation.html", "Cross-Validation Adding Another Validation Set K-fold Cross-Validation Bootstrap Other Stuff", " Cross-Validation As noted in the previous section, in machine learning approaches we are particularly concerned with prediction error on new data. The simplest validation approach would be to split the data available into a training and test set as discussed previously. We estimate the model on the training data, and apply the model to the test data, get the predictions and measure our test error, selecting whichever model results in the least test error. A hypothetical learning curve display the results of such a process is shown to the right. While fairly simple, other approaches are more commonly used and result in better estimates of performance18. Adding Another Validation Set One technique that might be utilized for larger data sets, is to split the data into training, validation and final test sets. For example, one might take the original data and create something like a 60-20-20% split to create the needed data sets. The purpose of the initial validation set is to select the optimal model and determine the values of tuning parameters. These are parameters which generally deal with how complex a model one will allow, but for which one would have little inkling as to what they should be set at before hand (e.g. our \\(\\lambda\\) shrinkage parameter in regularized regression). We select models/tuning parameters that minimize the validation set error, and once the model is chosen examine test set error performance. In this way performance assessment is still independent of the model development process. An illustration of 3-fold classification. K-fold Cross-Validation In many cases we don’t have enough data for such a split, and the split percentages are arbitrary anyway, with results that would be specific to the split chosen. Instead we can take a typical data set and randomly split it into \\(\\kappa=10\\) equal-sized (or close to it) parts. Take the first nine partitions and use them as the training set. With chosen model, make predictions on the test set. Now do the same but this time use the 9th partition as the holdout set. Repeat the process until each of the initial 10 partitions of data have been used as the test set. Average the error across all procedures for our estimate of prediction error. With enough data, this (and the following methods) could be used as the validation procedure before eventual performance assessment on an independent test set with the final chosen model. Leave-one-out Cross-Validation Leave-one-out (LOO) cross-validation is pretty much the same thing but where \\(\\kappa=N\\). In other words, we train a model for all observations except the \\(\\kappa^{th}\\) one, assessing fit on the observation that was left out. We then cycle through until all observations have been left out once to obtain an average accuracy. Of the two, K-fold may have relatively higher bias but less variance, while LOO would have the converse problem, as well as possible computational issues19. K-fold’s additional bias would be diminished would with increasing sample sizes, and generally 5 or 10-fold cross-validation is recommended. However, many model selection techniques (e.g. via AIC) have a leave-one-out interpretation. Bootstrap With a bootstrap approach, we draw \\(B\\) random samples with replacement from our original data set, creating \\(B\\) bootstrapped data sets of the same size as the original data. We use the \\(B\\) data sets as training sets and, using the original data as the test set, average the prediction error across the models. Other Stuff Along with the above there are variations such as repeated cross validation, the ‘.632’ bootstrap and so forth. One would want to do a bit of investigating, but \\(\\kappa\\)-fold and bootstrap approaches generally perform well. If variable selection is part of the goal, one should be selecting subsets of predictors as part of the cross-validation process, not at some initial data step. Along with some of the other works cited, see Harrell (2015) for a good discussion of model validation.↩ For squared-error loss situations, there is a Generalized cross-validation (GCV) that can be estimated more directly without actually going to the entire LOO procedure, and functions similarly to AIC.↩ "],
["model-assessment-selection.html", "Model Assessment &amp; Selection Beyond Classification Accuracy: Other Measures of Performance", " Model Assessment &amp; Selection In typical model comparison within the standard linear model framework, there are a number of ways in which we might assess performance across competing models. For standard OLS regression we might examine adjusted-\\(R^2\\), or with the generalized linear models we might pick a model with the lowest AIC20. As we have already discussed, in the machine learning context we are interested in models that reduce e.g. squared error loss (regression) or misclassification error (classification). However in dealing with many models some differences in performance may be arbitrary. Beyond Classification Accuracy: Other Measures of Performance In typical classification situations we are interested in overall accuracy. However there are situations, not uncommon, in which simple accuracy isn’t a good measure of performance. As an example, consider the prediction of the occurrence of a rare disease. Guessing a non-event every time might result in 99.9% accuracy, but that isn’t how we would prefer to go about assessing some classifier’s performance. To demonstrate other sources of classification information, we will use the following 2x2 table that shows values of some binary outcome (0 = non-event, 1 = event occurs) to the predictions made by some model for that response (arbitrary model). Both a table of actual values, often called a confusion matrix21, and an abstract version are provided. True Positive, False Positive, True Negative, False Negative: Above, these are A, B, D, and C respectively. Accuracy: Number of correct classifications out of all predictions ((A+D)/Total). In the above example this would be (41+13)/91, about 59%. Error Rate: 1 - Accuracy. Sensitivity: is the proportion of correctly predicted positives to all true positive events: A/(A+C). In the above example this would be 41/57, about 72%. High sensitivity would suggest a low type II error rate (see below), or high statistical power. Also known as true positive rate. Specificity: is the proportion of correctly predicted negatives to all true negative events: D/(B+D). In the above example this would be 13/34, about 38%. High specificity would suggest a low type I error rate (see below). Also known as true negative rate. Postive Predictive Value (PPV): proportion of true positives of those that are predicted positives: A/A+B. In the above example this would be 41/62, about 66%. Negative Predictive Value (NPV): proportion of true negatives of those that are predicted negative: D/C+D. In the above example this would be 13/29, about 45%. Precision: See PPV. Recall: See sensitivity. Lift: Ratio of positive predictions given actual positives to the proportion of positive predictions out of the total: (A/(A+C))/((A+B)/Total). In the above example this would be (41/(41+16))/((41+21)/(91)), or 1.06. F Score (F1 score): Harmonic mean of precision and recall: 2*(Precision*Recall)/(Precision+Recall). In the above example this would be 2*(.66*.72)/(.66+.72), about 0.69. Type I Error Rate (false positive rate): proportion of true negatives that are incorrectly predicted positive: B/B+D. In the above example this would be 21/34, about 62%. Also known as alpha. Type II Error Rate (false negative rate): proportion of true positives that are incorrectly predicted negative: C/C+A. In the above example this would be 16/57, about 28%. Also known as beta. False Discovery Rate: proportion of false positives among all positive predictions: B/A+B. In the above example this would be 21/62, about 34%. Often used in multiple comparison testing in the context of ANOVA. Phi coefficient: A measure of association: (A*D - B*C)/(sqrt((A+C)*(D+B)*(A+B)*(D+C))). In the above example this would be 0.11. Note the following summary of several measures where \\(N_+\\) and \\(N_-\\) are the total true positive values and total true negative values respectively, and \\(T_+\\), \\(F_+\\), \\(T_-\\) and \\(F_-\\) are true positive, false positive, etc.: testdf &lt;- data.frame(locationName= c(&quot;台北&quot;,&quot;新北市&quot;,&quot;台南市&quot;), TEMP=c(30,29,28)) testdf locationName TEMP 1 &lt;U+53F0&gt;&lt;U+5317&gt; 30 2 &lt;U+65B0&gt;&lt;U+5317&gt;&lt;U+5E02&gt; 29 3 &lt;U+53F0&gt;&lt;U+5357&gt;&lt;U+5E02&gt; 28 library(DT) datatable(testdf) There are many other measures such as area under a Receiver Operating Curve (ROC), odds ratio, and even more names for some of the above. The gist is that given any particular situation you might be interested in one or several of them, and it would generally be a good idea to look at a few. In situations where it is appropriate to calculate in the first place, AIC can often compare to the bootstrap and k-fold cross-validation approaches.↩ This term has always struck me as highly sub-optimal.↩ "],
["process-overview.html", "Process Overview Data Preparation Model Selection Model Assessment", " Process Overview Despite the facade of a polished product one finds in published research, most of the approach with the statistical analysis of data is full of data preparation, starts and stops, debugging, re-analysis, tweaking and fine-tuning etc. Statistical learning is no different in this sense. Before we begin with explicit examples, it might be best to give a general overview of the path we’ll take. Data Preparation As with any typical statistical project, probably most of the time will be spent preparing the data for analysis. Data is never ready to analyze right away, and careful checks must be made in order to ensure the integrity of the information. This would include correcting errors of entry, noting extreme values, possibly imputing missing data and so forth. In addition to these typical activities, we will discuss a couple more things to think about during this initial data examination when engaged in machine learning. Define Data and Data Partitions As we have noted previously, ideally we will have enough data to create a hold-out, test, or validation data set. This would be some random partition of the data such that we could safely conclude that the data in the test set comes from the same population as the training set. The training set is used to fit the initial models at various tuning parameter settings, with a ‘best’ model being that which satisfies some criterion on the validation set (or via a general validation process). With final model and parameters chosen, generalization error will be assessed with the the performance of the final model on the test data. Feature Scaling Even with standard regression modeling, centering continuous variables (subtracting the mean) is a good idea so that intercepts and zero points in general are meaningful. Standardizing variables so that they have similar variances or ranges will help some procedures find their minimums faster. Another common transformation is min-max normalization22, which will transfer a scale to a new one of some chosen minimum and maximum. Note that whatever approach is done, it must be done after any explicit separation of data. So if you have separate training and test sets, they should be scaled separately. Feature Engineering If we’re lucky we’ll have ideas on potential combinations or other transformations of the predictors we have available. For example, in typical social science research there are two-way interactions one is often predisposed to try, or perhaps one can sum multiple items to a single scale score that may be more relevant. Another common technique is to use a dimension reduction scheme such as principal components, but this can (and probably should) actually be an implemented algorithm in the ML process23. One can implement a variety of such approaches in ML as well to create additional potentially relevant features, even automatically, but as a reminder, a key concern is overfitting, and doing broad construction of this sort with no contextual guidance would potentially be prone to such a pitfall. In other cases it may simply be not worth the time expense. Discretization While there may be some contextual exceptions to the rule, it is generally a pretty bad idea in standard statistical modeling to discretize/categorize continuous variables24. However some ML procedures will work better (or just faster) if dealing with discrete valued predictors rather than continuous. Others even require them; for example, logic regression needs binary input. While one could pick arbitrary intervals and cutpoints in an unsupervised fashion such as picking equal range bins or equal frequency bins, there are supervised algorithmic approaches that will use the information in the data to produce some ‘optimal’ discretization. It’s generally not a good idea to force things in data analysis, and given that a lot of data situations will be highly mixed, it seems easier to simply apply some scaling to preserve the inherent relationships in the data. Again though, if one has only a relative few continuous variables or a context in which it makes sense to, it’s probably better to leave continuous variables as such. Model Selection With data prepared and ready to analyze, one can use a validation process to come up with a viable model. Use an optimization procedure or a simple grid search over a set of specific values to examine models at different tuning parameters. Perhaps make a finer search once an initial range of good performing values is found, though one should not split hairs over arbitrarily close performance. Select a ‘best’ model given some criterion such as overall accuracy, or if concerned about over fitting, select the simplest model within one standard error of the accuracy of the best, or perhaps the simplest within X% of the best model. For highly skewed classes, one might need to use a different measure of performance besides accuracy. If one has a great many predictor variables, one may use the model selection process to select features that are ‘most important’. Model Assessment With tuning parameters/features chosen, we then examine performance on the independent test set (or via some validation procedure). For classification problems, consider other statistics besides accuracy as measures of performance, especially if classes are unbalanced. Consider other analytical techniques that are applicable and compare performance among the different approaches. One can even combine disparate models’ predictions to possibly create an even better classifier25. See, for example, the rescale function in the scales package.↩ For example, via principal components or partial least squares regression.↩ See Harrell (2015) for a good summary of reasons why not to.↩ The topic of ensembles is briefly noted later.↩ "],
["appendix.html", "Appendix Bias Variance Demo", " Appendix Bias Variance Demo x = runif(1000) ytrue = sin(3*pi*x) basedat = cbind(x,ytrue)[order(x),] gendatfunc = function(noise=.5, n=1000){ x = runif(n) y = sin(3*pi*x) + rnorm(n, sd=noise) # truth d = cbind(x, y) d } gendat = replicate(100, gendatfunc(n=100)) str(gendat) library(kernlab) rbf1 = apply(gendat, 3, function(d) predict(gausspr(y~x, data=data.frame(d), kpar=list(sigma=.5)), newdata = data.frame(x), type=&#39;response&#39;)) rbf2 = apply(gendat, 3, function(d) predict(gausspr(y~x, data=data.frame(d)), newdata = data.frame(x), type=&#39;response&#39;) ) library(ggplot2); library(tidyverse); library(gridExtra) rbf1_samp = rbf1 %&gt;% data.frame %&gt;% cbind(x, .) %&gt;% slice(sample(1:100, 25)) %&gt;% gather(key=sample, value=yhat, -x) rbf2_samp = rbf2 %&gt;% data.frame %&gt;% cbind(x, .) %&gt;% slice(sample(1:100, 25)) %&gt;% gather(key=sample, value=yhat, -x) g1 = ggplot(data=data.frame(basedat)) + geom_blank() + geom_line(aes(x=x, y=yhat, group=sample), color=&#39;#ff5503&#39;, alpha=.25, data=rbf1_samp) + ylim(c(-1.5, 1.5)) + labs(y=&#39;&#39;, title=&#39;Low Variance&#39;) + lazerhawk::theme_trueMinimal() g2 = ggplot(data=data.frame(basedat)) + geom_line(aes(x=x, y=ytrue), color=&#39;#1e90ff&#39;) + geom_line(aes(x=x, y=yhat), color=&#39;#ff5503&#39;, data.frame(yhat=rowMeans(rbf1))) + ylim(c(-1.5, 1.5)) + labs(y=&#39;&#39;, title=&#39;High Bias&#39;) + lazerhawk::theme_trueMinimal() g3 = ggplot(data=data.frame(basedat)) + geom_blank() + geom_line(aes(x=x, y=yhat, group=sample), color=&#39;#ff5503&#39;, alpha=.25, data=rbf2_samp) + ylim(c(-1.5, 1.5)) + labs(y=&#39;&#39;, title=&#39;High Variance&#39;) + lazerhawk::theme_trueMinimal() g4 = ggplot(data=data.frame(basedat)) + geom_line(aes(x=x, y=ytrue), color=&#39;#1e90ff&#39;) + geom_line(aes(x=x, y=yhat), color=&#39;#ff5503&#39;, data.frame(yhat=rowMeans(rbf2))) + ylim(c(-1.5, 1.5)) + labs(y=&#39;&#39;, title=&#39;Low Bias&#39;) + lazerhawk::theme_trueMinimal() grid.arrange(g1, g2, g3, g4, ncol=2) "]
]
